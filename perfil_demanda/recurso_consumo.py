#!/usr/bin/env python3
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from datetime import datetime, timedelta

def analizar_estacion(estacion, sheet_name, recurso_solar_file, cargas_file):
    """Analiza una estaci√≥n espec√≠fica (invierno o verano)"""
    
    print(f"\n{'='*80}")
    print(f"ANALIZANDO DATOS DE {estacion.upper()}")
    print(f"{'='*80}")
    
    # Archivos de salida espec√≠ficos por estaci√≥n
    output_png = f"/home/nicole/UA/OFFGRID/OFFGRID/results/sistema_fotovoltaico_{estacion.lower()}.png"
    output_csv = f"/home/nicole/UA/OFFGRID/OFFGRID/results/datos_sistema_fotovoltaico_{estacion.lower()}.csv"
    
    # 1. CARGAR DATOS DE IRRADIANCIA
    print(f"\nüîç DIAGN√ìSTICO DE DATOS SOLARES")
    print("=" * 50)
    
    df_solar = pd.read_excel(recurso_solar_file, sheet_name=sheet_name)
    print(f"üìÅ Archivo solar: {recurso_solar_file}")
    print(f"üìã Hoja: {sheet_name}")
    print(f"‚úÖ Datos solares cargados: {len(df_solar)} filas x {len(df_solar.columns)} columnas")
    
    # Mostrar estructura de datos solares
    print(f"\nüìä ESTRUCTURA DE DATOS SOLARES:")
    print(f"   Columnas disponibles: {list(df_solar.columns)}")
    print(f"   Tipos de datos:")
    for col in df_solar.columns:
        print(f"     {col}: {df_solar[col].dtype}")
    
    # Mostrar primeros registros solares
    print(f"\nüìã PRIMEROS 5 REGISTROS SOLARES:")
    print(df_solar.head())
    
    # Verificar datos faltantes en solar
    print(f"\n‚ùì DATOS FALTANTES EN SOLAR:")
    for col in df_solar.columns:
        faltantes = df_solar[col].isnull().sum()
        if faltantes > 0:
            print(f"   {col}: {faltantes} valores faltantes")
        else:
            print(f"   {col}: Sin datos faltantes")
    
    df_solar['Fecha_Hora'] = pd.to_datetime(df_solar['Fecha_Hora'])
    
    print(f"\nüìà ESTAD√çSTICAS SOLARES:")
    print(f"   GHI m√°ximo: {df_solar['GHI_W_m2'].max():.1f} W/m¬≤")
    print(f"   GHI m√≠nimo: {df_solar['GHI_W_m2'].min():.1f} W/m¬≤")
    print(f"   GHI promedio: {df_solar['GHI_W_m2'].mean():.1f} W/m¬≤")
    print(f"   Gmod m√°ximo: {df_solar['Gmod'].max():.1f} W/m¬≤")
    print(f"   Gmod m√≠nimo: {df_solar['Gmod'].min():.1f} W/m¬≤")
    print(f"   Gmod promedio: {df_solar['Gmod'].mean():.1f} W/m¬≤")
    print(f"   Horas disponibles: {sorted(df_solar['Hora'].unique())}")
    
    # 2. CARGAR Y PROCESAR DATOS DE CONSUMO
    print(f"\nüîç DIAGN√ìSTICO DE DATOS DE CONSUMO")
    print("=" * 50)
    
    df_cargas = pd.read_excel(cargas_file, header=0)
    print(f"üìÅ Archivo de cargas: {cargas_file}")
    print(f"‚úÖ Datos cargados: {len(df_cargas)} filas x {len(df_cargas.columns)} columnas")
    
    # Mostrar estructura de datos de consumo
    print(f"\nüìä ESTRUCTURA DE DATOS DE CONSUMO:")
    print(f"   Columnas disponibles: {list(df_cargas.columns)}")
    print(f"   Tipos de datos:")
    for col in df_cargas.columns:
        print(f"     {col}: {df_cargas[col].dtype}")
    
    # Mostrar primeros registros
    print(f"\nüìã PRIMEROS 5 REGISTROS DE CONSUMO:")
    print(df_cargas.head())
    
    # Verificar datos faltantes en consumo
    print(f"\n‚ùì DATOS FALTANTES EN CONSUMO:")
    for col in df_cargas.columns:
        faltantes = df_cargas[col].isnull().sum()
        if faltantes > 0:
            print(f"   {col}: {faltantes} valores faltantes")
        else:
            print(f"   {col}: Sin datos faltantes")
    
    carga_cols = [c for c in df_cargas.columns if c.lower() != "hora"]
    print(f"\nüîß PROCESANDO DATOS DE CONSUMO:")
    print(f"   Columnas de carga identificadas: {carga_cols}")
    print(f"   Total de columnas de carga: {len(carga_cols)}")
    
    # Convertir hora
    df_cargas["Hour"] = df_cargas["Hora"].astype(float)
    print(f"   Horas √∫nicas en datos: {sorted(df_cargas['Hour'].unique())}")
    
    # Calcular consumo total por fila
    df_cargas["Total_Consumo"] = df_cargas[carga_cols].sum(axis=1)
    print(f"\nüìä CONSUMO TOTAL POR FILA:")
    print(f"   Consumo m√°ximo por fila: {df_cargas['Total_Consumo'].max():.1f} W")
    print(f"   Consumo m√≠nimo por fila: {df_cargas['Total_Consumo'].min():.1f} W")
    print(f"   Consumo promedio por fila: {df_cargas['Total_Consumo'].mean():.1f} W")
    
    # Mostrar algunos ejemplos de consumo
    print(f"\nüìã EJEMPLOS DE CONSUMO POR FILA:")
    for i in range(min(5, len(df_cargas))):
        fila = df_cargas.iloc[i]
        print(f"   Fila {i+1}: Hora={fila['Hour']:.1f}, Total={fila['Total_Consumo']:.1f}W")
        for col in carga_cols:
            if fila[col] > 0:
                print(f"     {col}: {fila[col]:.1f}W")
    
    # Usar todos los valores originales con l√≠neas normales
    df_hourly = df_cargas.set_index("Hour")[["Total_Consumo"]]
    print(f"\nüìà DATOS AGRUPADOS POR HORA:")
    print(f"   Filas resultantes: {len(df_hourly)}")
    print(f"   Horas disponibles: {sorted(df_hourly.index)}")
    
    print(f"\nüîç VERIFICANDO DATOS DE CONSUMO:")
    print("Valores de consumo (primeros 10):")
    for hora, consumo in df_hourly["Total_Consumo"].head(10).items():
        print(f"   {hora:4.1f}h ‚Üí {consumo:6.1f}W")
    
    # 3. PAR√ÅMETROS DEL SISTEMA FOTOVOLTAICO
    Pmax = 580  # Wp por m√≥dulo
    eficiencia = 0.221  # Eficiencia del m√≥dulo
    area_modulo = 2.645  # m¬≤ por m√≥dulo
    capacidad_max = 17400  # Wp total del sistema
    num_modulos = capacidad_max / Pmax
    perdidas = 0.04  # 4% de p√©rdidas
    
    PR = 0.8
    ef_inv = 0.976

    # 4. CALCULAR GENERACI√ìN FOTOVOLTAICA
    # Usar Gmod (irradiancia en el plano del m√≥dulo)
    df_solar['Generacion_PV'] = (df_solar['Gmod'] * area_modulo * eficiencia * num_modulos * PR * ef_inv) #(1 - perdidas))
    # ‚ñ∏ Comprobaci√≥n paso a paso
    print("=== CHECK INTERMEDIO ===")
    print(f"HŒ≤ integrada ............... {df_solar['Gmod'].sum()/1000:.2f} kWh/m¬≤")
    print(f"√Årea total m√≥dulos ......... {area_modulo*num_modulos:.2f} m¬≤")
    print(f"Œ∑ m√≥dulo ................... {eficiencia:.3f}")
    print(f"PR campo (sin inversor) .... {PR:.3f}")
    print(f"Œ∑ inversor ................. {ef_inv:.3f}")
    print(f"Factor total (excepto √°rea)  {(eficiencia*PR*ef_inv):.3f}")
    print(f"Energ√≠a AC diaria calculada  {df_solar['Generacion_PV'].sum()/1000:.2f} kWh")
    print("==========================")
    
    H_inv_real = np.trapz(df_solar['Gmod'], df_solar['Hora']) / 1000  # kWh/m¬≤
    print(f"üîé Gmod integrado (hoja Excel) = {H_inv_real:.2f} kWh/m¬≤ d√≠a")

    # 5. EXPANDIR DATOS SOLARES PARA COINCIDIR CON RESOLUCI√ìN DE CARGAS
    print(f"\nüîç DIAGN√ìSTICO DE RESOLUCI√ìN TEMPORAL:")
    print("=" * 50)
    print(f"   Datos solares: {len(df_solar)} filas (resoluci√≥n horaria)")
    print(f"   Datos consumo: {len(df_cargas)} filas (resoluci√≥n media hora)")
    print(f"   Horas solares: {sorted(df_solar['Hora'].unique())}")
    print(f"   Horas consumo: {sorted(df_cargas['Hora'].unique())[:10]}...")  # Mostrar solo las primeras 10
    
    # Verificar si necesitamos interpolar
    if len(df_solar) != len(df_cargas):
        print(f"‚ö†Ô∏è  ADVERTENCIA: Resoluciones temporales diferentes")
        print(f"   Interpolando datos solares de {len(df_solar)} a {len(df_cargas)} puntos")
    else:
        print(f"‚úÖ Resoluciones temporales coinciden")
    
    # En lugar de interpolar consumo, vamos a expandir los datos solares
    horas_expandidas = df_cargas['Hora'].values
    
    # Interpolar datos solares a resoluci√≥n de medias horas
    ghi_expandido = np.interp(horas_expandidas, df_solar['Hora'], df_solar['GHI_W_m2'])
    gmod_expandido = np.interp(horas_expandidas, df_solar['Hora'], df_solar['Gmod'])
    
    print(f"   Datos interpolados: {len(ghi_expandido)} puntos")
    print(f"   GHI interpolado - Max: {ghi_expandido.max():.1f}, Min: {ghi_expandido.min():.1f}")
    print(f"   Gmod interpolado - Max: {gmod_expandido.max():.1f}, Min: {gmod_expandido.min():.1f}")
    
    # Crear DataFrame expandido
    df_expandido = pd.DataFrame({
        'Hora': horas_expandidas,
        'GHI_W_m2': ghi_expandido,
        'Gmod': gmod_expandido
    })
    
    # Calcular generaci√≥n PV con resoluci√≥n expandida
    df_expandido['Generacion_PV'] = (df_expandido['Gmod'] * area_modulo * eficiencia * num_modulos * PR * ef_inv) #(1 - perdidas))
    
    # Usar consumo original sin interpolar
    df_expandido['Consumo'] = df_hourly['Total_Consumo'].values
    
    print(f"\nüîç VERIFICACI√ìN FINAL DE CONSUMO:")
    print(f"   Longitud de datos expandidos: {len(df_expandido)}")
    print(f"   Longitud de datos de consumo: {len(df_hourly)}")
    print(f"   Consumo m√°ximo en datos expandidos: {df_expandido['Consumo'].max():.1f} W")
    print(f"   Consumo m√≠nimo en datos expandidos: {df_expandido['Consumo'].min():.1f} W")
    print(f"   Consumo promedio en datos expandidos: {df_expandido['Consumo'].mean():.1f} W")
    
    # CORREGIR: Calcular consumo total diario correctamente
    # Los datos est√°n en resoluci√≥n de media hora, pero representan el consumo promedio por intervalo
    # Para obtener el consumo diario: sumar todos y dividir por 24 para obtener W/hora promedio
    consumo_promedio_por_hora = df_expandido['Consumo'].sum() / 24  # W/hora promedio
    consumo_total_wh = consumo_promedio_por_hora * 24  # W/hora * 24 horas = Wh/d√≠a
    energia_consumo_total = consumo_promedio_por_hora * 24 / 1000  # W/hora * 24h / 1000 = kWh/d√≠a
    print(f"   Consumo promedio por hora: {consumo_promedio_por_hora:.1f} W/hora")
    print(f"   Consumo total diario (CORREGIDO): {consumo_total_wh:.1f} Wh")
    print(f"   Consumo total diario (kWh): {consumo_total_wh/1000:.3f} kWh")
    
    # Verificar que los datos coincidan
    if len(df_expandido) != len(df_hourly):
        print(f"‚ö†Ô∏è  ADVERTENCIA: Longitudes diferentes - Expandido: {len(df_expandido)}, Hourly: {len(df_hourly)}")
    else:
        print(f"‚úÖ Longitudes coinciden: {len(df_expandido)}")
    
    # 6. CREAR EL GR√ÅFICO CON TRES PANELES
    fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(12, 10), sharex=True)
    
    # ============= PANEL 1: IRRADIANCIA SOLAR =============
    # Convertir a kW/m¬≤
    ghi_kw = df_expandido['GHI_W_m2'] / 1000
    gmod_kw = df_expandido['Gmod'] / 1000
    
    # Calcular energ√≠as usando m√©todo coherente
    energia_ghi_total = np.sum(ghi_kw) * 0.5  # kW/m¬≤ * 0.5h = kWh/m¬≤
    energia_gmod_total = np.sum(gmod_kw) * 0.5  # kW/m¬≤ * 0.5h = kWh/m¬≤
    
    ax1.plot(df_expandido['Hora'], ghi_kw, 'b-', linewidth=2, 
             label=f'GHI (Total = {energia_ghi_total:.3f} kWh/m¬≤)', color='tab:blue')
    ax1.fill_between(df_expandido['Hora'], ghi_kw, alpha=0.3, color='tab:blue')
    
    ax1.plot(df_expandido['Hora'], gmod_kw, 'g-', linewidth=2,
             label=f'Gmod (Total = {energia_gmod_total:.3f} kWh/m¬≤)', color='tab:green')
    ax1.fill_between(df_expandido['Hora'], gmod_kw, alpha=0.3, color='tab:green')
    
    ax1.set_ylabel('GHI y Gmod (kW/m¬≤)', fontsize=16, fontweight='bold')
    ax1.legend(fontsize=14)
    ax1.grid(True, alpha=0.5)
    ax1.set_xlim(0, 24)
    
    # ============= PANEL 2: CONSUMO =============
    # Convertir consumo a kW
    consumo_kw = df_expandido['Consumo'] / 1000
    
    # Graficar consumo con l√≠neas normales
    ax2.plot(df_expandido['Hora'], consumo_kw, color='red', linewidth=2)
    ax2.fill_between(df_expandido['Hora'], 0, consumo_kw, alpha=0.3, color='red',
                     label=f'Consumo (Total = {energia_consumo_total:.3f} kWh)')
    ax2.set_ylabel('Consumo (kW)', fontsize=16, fontweight='bold')
    ax2.legend(fontsize=14)
    ax2.grid(True, alpha=0.5)
    ax2.set_xlim(0, 24)
    
    # ============= PANEL 3: GENERACI√ìN VS CONSUMO =============
    # Convertir generaci√≥n PV a kW
    generacion_pv_kw = df_expandido['Generacion_PV'] / 1000
    
    # Generaci√≥n Fotovoltaica
    # Usar m√©todo coherente: sumatoria con factor de 0.5h por intervalo
    energia_pv_total = np.sum(generacion_pv_kw) * 0.5  # kW * 0.5h = kWh
    ax3.plot(df_expandido['Hora'], generacion_pv_kw, linewidth=2,
             label=f'Generaci√≥n PV (Total = {energia_pv_total:.3f} kWh)', color='tab:purple')
    
    # Consumo con l√≠neas normales
    ax3.plot(df_expandido['Hora'], consumo_kw, color='tab:red', linewidth=2,
             label=f'Consumo (Total = {energia_consumo_total:.3f} kWh)')
    
    # M√âTODO EXACTO DEL NOTEBOOK PROFESIONAL
    # Calcular diferencia energ√©tica (Generaci√≥n - Consumo) en kW
    diferencia_energia_kw = generacion_pv_kw - consumo_kw
    
    # Separar en positiva (exceso) y negativa (d√©ficit)
    energia_disponible_positiva = diferencia_energia_kw.clip(lower=0)
    energia_disponible_negativa = diferencia_energia_kw.clip(upper=0)
    
    # Agregar los nuevos c√°lculos al DataFrame expandido
    df_expandido['Diferencia_Energia_kW'] = diferencia_energia_kw
    df_expandido['Exceso_Energia_kW'] = energia_disponible_positiva  
    df_expandido['Deficit_Energia_kW'] = energia_disponible_negativa
    
    # Graficar la l√≠nea de diferencia energ√©tica con l√≠neas normales
    ax3.plot(df_expandido['Hora'], diferencia_energia_kw,
             label='Energ√≠a Disponible', color='tab:orange', linewidth=2)
    
    # Calcular √°reas usando m√©todo coherente
    # Usar sumatoria con factor de 0.5h por intervalo para ser coherente con el c√°lculo de consumo
    energia_exceso_total = np.sum(energia_disponible_positiva) * 0.5  # kW * 0.5h = kWh
    energia_deficit_total = abs(np.sum(energia_disponible_negativa)) * 0.5  # kW * 0.5h = kWh
    
    # Rellenar √°reas con l√≠neas normales
    ax3.fill_between(df_expandido['Hora'], 0, diferencia_energia_kw, 
                     where=(diferencia_energia_kw >= 0),
                     alpha=0.3, color='green', interpolate=True,
                     label=f'Exceso = {energia_exceso_total:.3f} kWh')
    
    ax3.fill_between(df_expandido['Hora'], 0, diferencia_energia_kw, 
                     where=(diferencia_energia_kw < 0),
                     alpha=0.3, color='red', interpolate=True,
                     label=f'D√©ficit = {energia_deficit_total:.3f} kWh')
    
    ax3.set_xlabel('Fecha', fontsize=16, fontweight='bold')
    ax3.set_ylabel('Generaci√≥n PV (kW)', fontsize=16, fontweight='bold')
    ax3.legend(fontsize=14)
    ax3.grid(True, alpha=0.5)
    ax3.set_xlim(0, 24)
    
    # Formatear eje x para mostrar horas
    hora_labels = [f"{int(h):02d}:00" for h in range(0, 25, 2)]
    hora_ticks = list(range(0, 25, 2))
    
    # Solo aplicar formato al √∫ltimo eje (ax3)
    ax3.set_xticks(hora_ticks)
    ax3.set_xticklabels(hora_labels, rotation=45, fontsize=14)
    
    # Configuraci√≥n general
    plt.xlabel('Fecha', fontsize=16, fontweight='bold')
    plt.suptitle(f'Sistema Fotovoltaico - {estacion.title()}', fontsize=20, fontweight='bold', y=0.98)
    plt.tight_layout()
    plt.savefig(output_png, dpi=300, bbox_inches='tight')
    plt.show()
    
    # 7. GENERAR CSV CON TODOS LOS DATOS GRAFICADOS
    print("=" * 70)
    print("GENERANDO ARCHIVO CSV CON DATOS GRAFICADOS...")
    print("=" * 70)
    
    # Crear DataFrame final con todos los datos para el CSV
    df_csv = df_expandido.copy()
    
    # Agregar columnas adicionales con informaci√≥n del sistema
    df_csv['Capacidad_Sistema_Wp'] = capacidad_max
    df_csv['Num_Modulos'] = num_modulos
    df_csv['Eficiencia_Modulo'] = eficiencia
    df_csv['Area_Total_m2'] = area_modulo * num_modulos
    df_csv['Perdidas_Sistema'] = perdidas
    
    # Calcular energ√≠as acumuladas hasta cada punto (integral num√©rica)
    # CORREGIR: Los datos est√°n en resoluci√≥n de media hora, pero representan valores promedio
    # Para energ√≠a acumulada: usar factor de 0.5h por intervalo (correcto para integral)
    df_csv['Energia_GHI_Acumulada_Wh'] = np.cumsum(df_csv['GHI_W_m2'] * 0.5)  # 0.5h por intervalo
    df_csv['Energia_Gmod_Acumulada_Wh'] = np.cumsum(df_csv['Gmod'] * 0.5)
    df_csv['Energia_PV_Acumulada_Wh'] = np.cumsum(df_csv['Generacion_PV'] * 0.5)
    # CORREGIR: Calcular energ√≠a de consumo acumulada correctamente
    # Usar los valores reales de consumo multiplicados por 0.5h por intervalo
    df_csv['Energia_Consumo_Acumulada_Wh'] = np.cumsum(df_csv['Consumo'] * 0.5)
    
    print(f"\nüìä ENERG√çAS ACUMULADAS (CORREGIDAS):")
    print(f"   Energ√≠a GHI acumulada final: {df_csv['Energia_GHI_Acumulada_Wh'].iloc[-1]:.1f} Wh")
    print(f"   Energ√≠a Gmod acumulada final: {df_csv['Energia_Gmod_Acumulada_Wh'].iloc[-1]:.1f} Wh")
    print(f"   Energ√≠a PV acumulada final: {df_csv['Energia_PV_Acumulada_Wh'].iloc[-1]:.1f} Wh")
    print(f"   Energ√≠a Consumo acumulada final: {df_csv['Energia_Consumo_Acumulada_Wh'].iloc[-1]:.1f} Wh")
    
    # Reordenar columnas para mejor legibilidad
    columnas_ordenadas = [
        'Hora',
        'GHI_W_m2', 
        'Gmod',
        'Generacion_PV',
        'Consumo',
        'Diferencia_Energia_kW',
        'Exceso_Energia_kW', 
        'Deficit_Energia_kW',
        'Energia_GHI_Acumulada_Wh',
        'Energia_Gmod_Acumulada_Wh', 
        'Energia_PV_Acumulada_Wh',
        'Energia_Consumo_Acumulada_Wh',
        'Capacidad_Sistema_Wp',
        'Num_Modulos',
        'Eficiencia_Modulo',
        'Area_Total_m2',
        'Perdidas_Sistema'
    ]
    
    # Verificar que todas las columnas existan antes de reordenar
    columnas_existentes = [col for col in columnas_ordenadas if col in df_csv.columns]
    columnas_faltantes = [col for col in columnas_ordenadas if col not in df_csv.columns]
    
    if columnas_faltantes:
        print(f"‚ö†Ô∏è  ADVERTENCIA: Columnas faltantes en CSV: {columnas_faltantes}")
        print(f"   Columnas disponibles: {list(df_csv.columns)}")
    
    df_csv = df_csv[columnas_existentes]
    
    # Guardar CSV
    df_csv.to_csv(output_csv, index=False, encoding='utf-8')
    
    print(f"‚úÖ Archivo CSV generado exitosamente: {output_csv}")
    print(f"üìä Datos incluidos: {len(df_csv)} filas x {len(df_csv.columns)} columnas") 
    print("üìà Columnas disponibles:")
    for i, col in enumerate(df_csv.columns, 1):
        print(f"   {i:2d}. {col}")
    
    # 8. IMPRIMIR RESUMEN
    print("=" * 70)
    print("RESUMEN DEL SISTEMA FOTOVOLTAICO")
    print("=" * 70)
    print("ESPECIFICACIONES DEL SISTEMA:")
    print(f"‚Ä¢ M√≥dulos: {num_modulos:.0f} x {Pmax}W")
    print(f"‚Ä¢ Capacidad instalada: {capacidad_max:.0f} Wp ({capacidad_max/1000:.1f} kWp)")
    print(f"‚Ä¢ Eficiencia del m√≥dulo: {eficiencia*100:.1f}%")
    print(f"‚Ä¢ √Årea total de m√≥dulos: {area_modulo * num_modulos:.1f} m¬≤ ({area_modulo:.1f} m¬≤ cada uno)")
    print(f"‚Ä¢ P√©rdidas del sistema: {perdidas*100:.1f}%")
    print("-" * 70)
    print("RESULTADOS ENERG√âTICOS:")
    print(f"‚Ä¢ Energ√≠a solar disponible (GHI): {energia_ghi_total:.2f} kWh/m¬≤¬∑d√≠a")
    print(f"‚Ä¢ Energ√≠a solar inclinada (Gmod): {energia_gmod_total:.2f} kWh/m¬≤¬∑d√≠a")
    print(f"‚Ä¢ Generaci√≥n fotovoltaica total: {energia_pv_total:.2f} kWh/d√≠a")
    print(f"‚Ä¢ Consumo total: {energia_consumo_total:.2f} kWh/d√≠a")
    print(f"‚Ä¢ Energ√≠a excedente: {energia_exceso_total:.2f} kWh/d√≠a")
    print(f"‚Ä¢ Energ√≠a d√©ficit: {energia_deficit_total:.2f} kWh/d√≠a")
    print(f"‚Ä¢ Energ√≠a diaria requerida para bater√≠as: {energia_deficit_total:.2f} kWh/d√≠a")
    print(f"‚Ä¢ Balance energ√©tico: {energia_pv_total - energia_consumo_total:.2f} kWh/d√≠a")
    print("-" * 70)
    if energia_pv_total > energia_consumo_total:
        print("‚úÖ SISTEMA SOBREDIMENSIONADO: La generaci√≥n supera el consumo")
    elif energia_pv_total < energia_consumo_total:
        print("‚ö†Ô∏è  SISTEMA SUBDIMENSIONADO: El consumo supera la generaci√≥n")
    else:
        print("‚öñÔ∏è  SISTEMA BALANCEADO: Generaci√≥n = Consumo")
    print("=" * 70)
    
    return {
        'estacion': estacion,
        'energia_pv_total': energia_pv_total,
        'energia_consumo_total': energia_consumo_total,
        'energia_exceso_total': energia_exceso_total,
        'energia_deficit_total': energia_deficit_total,
        'balance_energetico': energia_pv_total - energia_consumo_total,
        'csv_file': output_csv,
        'png_file': output_png
    }

def main():
    """Funci√≥n principal que analiza ambas estaciones"""
    
    # Rutas de archivos
    recurso_solar_file = "/home/nicole/UA/OFFGRID/OFFGRID/data/Recurso_solar.xlsx"
    cargas_file = "/home/nicole/UA/OFFGRID/OFFGRID/data/cargas_opt.xlsx"
    
    # Analizar ambas estaciones
    resultados = []
    
    # 1. INVIERNO
    resultado_invierno = analizar_estacion(
        estacion="Invierno",
        sheet_name="Solsticio_Invierno_20Jun", 
        recurso_solar_file=recurso_solar_file,
        cargas_file=cargas_file
    )
    resultados.append(resultado_invierno)
    
    # 2. VERANO  
    resultado_verano = analizar_estacion(
        estacion="Verano",
        sheet_name="Solsticio_Verano_21Dic",
        recurso_solar_file=recurso_solar_file, 
        cargas_file=cargas_file
    )
    resultados.append(resultado_verano)
    
    # 3. RESUMEN COMPARATIVO
    print(f"\n{'='*80}")
    print("RESUMEN COMPARATIVO ANUAL")
    print(f"{'='*80}")
    
    for resultado in resultados:
        print(f"\nüåü {resultado['estacion'].upper()}:")
        print(f"   Generaci√≥n PV: {resultado['energia_pv_total']:.2f} kWh/d√≠a")
        print(f"   Consumo:       {resultado['energia_consumo_total']:.2f} kWh/d√≠a") 
        print(f"   Balance:       {resultado['balance_energetico']:.2f} kWh/d√≠a")
        print(f"   Exceso:        {resultado['energia_exceso_total']:.2f} kWh/d√≠a")
        print(f"   D√©ficit:       {resultado['energia_deficit_total']:.2f} kWh/d√≠a")
    
    # Comparaci√≥n
    diferencia_generacion = resultado_verano['energia_pv_total'] - resultado_invierno['energia_pv_total']
    print(f"\nüìä DIFERENCIA ESTACIONAL:")
    print(f"   Generaci√≥n extra en verano: {diferencia_generacion:.2f} kWh/d√≠a ({diferencia_generacion/resultado_invierno['energia_pv_total']*100:.1f}% m√°s)")
    
    print(f"\nüìÅ ARCHIVOS GENERADOS:")
    for resultado in resultados:
        print(f"   {resultado['estacion']}: {resultado['csv_file']}")
        print(f"   {resultado['estacion']}: {resultado['png_file']}")
    
    print(f"\n{'='*80}")

if __name__ == "__main__":
    main()